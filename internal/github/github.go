package github

import (
	"fmt"
	"os"	"strings"

	"promptgaurd/internal/runner"
)

// GenerateAnnotations creates GitHub workflow annotations for test failures
func GenerateAnnotations(results *runner.Results) error {
	if !isGitHubActions() {
		return nil // Skip if not running in GitHub Actions
	}

	for _, test := range results.TestResults {
		if test.Status == "failed" {
			// Generate annotation for each failed test
			message := buildFailureMessage(test)
			
			// Output GitHub annotation format
			fmt.Printf("::error file=%s,title=PromptGuard Test Failure::%s\n", 
				test.PromptFile, message)
		}
	}

	return nil
}

// UpdateBadge updates the PromptGuard badge status
func UpdateBadge(results *runner.Results) error {
	if !isGitHubActions() {
		return nil
	}

	status := "passing"
	color := "brightgreen"
	
	if results.HasFailures() {
		status = "failing"
		color = "red"
	}

	// Create badge URL
	badgeURL := fmt.Sprintf("https://img.shields.io/badge/PromptGuard-%s-%s", status, color)
	
	// Output environment variable for GitHub Actions
	fmt.Printf("PROMPTGUARD_BADGE_URL=%s\n", badgeURL)
	
	// Write to GitHub Actions output
	if outputFile := os.Getenv("GITHUB_OUTPUT"); outputFile != "" {
		file, err := os.OpenFile(outputFile, os.O_APPEND|os.O_WRONLY, 0644)
		if err == nil {
			defer file.Close()
			file.WriteString(fmt.Sprintf("badge_url=%s\n", badgeURL))
		}
	}

	return nil
}

// SetJobSummary creates a GitHub Actions job summary
func SetJobSummary(results *runner.Results) error {
	if !isGitHubActions() {
		return nil
	}

	summaryFile := os.Getenv("GITHUB_STEP_SUMMARY")
	if summaryFile == "" {
		return nil
	}

	summary := generateJobSummary(results)
	
	return os.WriteFile(summaryFile, []byte(summary), 0644)
}

func isGitHubActions() bool {
	return os.Getenv("GITHUB_ACTIONS") == "true"
}

func buildFailureMessage(test runner.TestResult) string {
	var messages []string
	
	if test.Error != "" {
		messages = append(messages, test.Error)
	}
	
	for _, assertion := range test.Assertions {
		if !assertion.Passed {
			messages = append(messages, fmt.Sprintf("%s: %s", assertion.Type, assertion.Message))
		}
	}
	
	return strings.Join(messages, "; ")
}

func generateJobSummary(results *runner.Results) string {
	status := "✅ Passed"
	if results.HasFailures() {
		status = "❌ Failed"
	}

	summary := fmt.Sprintf(`# PromptGuard Test Results %s

## Summary
| Metric | Value |
|--------|-------|
| Tests | %d |
| Passed | %d |
| Failed | %d |
| Cost | $%.4f |
| Duration | %v |

`, status, results.Total, results.Passed, results.Failed, results.TotalCost, results.Duration)

	if results.HasFailures() {
		summary += "## Failures\n\n"
		for _, test := range results.TestResults {
			if test.Status == "failed" {
				summary += fmt.Sprintf("### ❌ %s\n", test.Name)
				summary += fmt.Sprintf("**File:** %s  \n", test.PromptFile)
				summary += fmt.Sprintf("**Provider:** %s  \n", test.Provider)
				
				if test.Error != "" {
					summary += fmt.Sprintf("**Error:** %s  \n", test.Error)
				}
				
				for _, assertion := range test.Assertions {
					if !assertion.Passed {
						summary += fmt.Sprintf("- **%s:** %s\n", assertion.Type, assertion.Message)
					}
				}
				
				summary += "\n"
			}
		}
	}

	summary += "\n---\n*Generated by [PromptGaurd by Chandresh](https://github.com/promptguard/promptguard)*"
	
	return summary
}
